# 异步操作优化方案

## 问题描述
当前项目在主线程执行数据库操作，会导致UI卡顿和ANR（Application Not Responding）。

## 优化方案

### 方案1：使用 Kotlin Coroutines + Flow（推荐）

如果考虑迁移到Kotlin，这是最现代化的方案：

```kotlin
// 在 DAO 中使用 suspend 和 Flow
@Dao
interface VocabularyDao {
    @Query("SELECT * FROM vocabulary_records")
    fun getAllVocabularyFlow(): Flow<List<VocabularyRecordEntity>>
    
    @Query("SELECT * FROM vocabulary_records WHERE id = :id")
    suspend fun getVocabularyById(id: Int): VocabularyRecordEntity?
    
    @Insert
    suspend fun insert(vocabulary: VocabularyRecordEntity): Long
}

// 在 Repository 中
class VocabularyRecordRepository(private val vocabularyDao: VocabularyDao) {
    // LiveData 自动在后台线程执行
    val allVocabulary: Flow<List<VocabularyRecordEntity>> = 
        vocabularyDao.getAllVocabularyFlow()
    
    suspend fun addVocabulary(vocabulary: VocabularyRecordEntity) {
        vocabularyDao.insert(vocabulary)
    }
}

// 在 Activity/ViewModel 中
class VocabularyActivity : AppCompatActivity() {
    private val viewModel: VocabularyViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        lifecycleScope.launch {
            viewModel.vocabularyList.collectLatest { list ->
                updateUI(list)
            }
        }
    }
    
    private fun saveVocabulary() {
        lifecycleScope.launch {
            try {
                viewModel.saveVocabulary(vocabularyItem)
                Toast.makeText(this@VocabularyActivity, "保存成功", Toast.LENGTH_SHORT).show()
            } catch (e: Exception) {
                Toast.makeText(this@VocabularyActivity, "保存失败", Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

### 方案2：使用 LiveData（推荐用于纯Java项目）

```java
// 在 DAO 中返回 LiveData
@Dao
public interface VocabularyDao {
    @Query("SELECT * FROM vocabulary_records")
    LiveData<List<VocabularyRecordEntity>> getAllVocabularyLive();
    
    @Query("SELECT COUNT(*) FROM vocabulary_records WHERE isMastered = 1")
    LiveData<Integer> getMasteredCount();
}

// 在 Repository 中
public class VocabularyRecordRepository {
    private VocabularyDao vocabularyDao;
    private ExecutorService executorService;
    
    public VocabularyRecordRepository(VocabularyDao dao) {
        this.vocabularyDao = dao;
        this.executorService = Executors.newSingleThreadExecutor();
    }
    
    // 读取操作返回 LiveData
    public LiveData<List<VocabularyRecordEntity>> getAllVocabulary() {
        return vocabularyDao.getAllVocabularyLive();
    }
    
    // 写入操作使用 ExecutorService
    public void addVocabularyRecord(VocabularyRecordEntity vocabulary, 
                                   OnCompleteListener listener) {
        executorService.execute(() -> {
            try {
                long id = vocabularyDao.insert(vocabulary);
                listener.onSuccess(id);
            } catch (Exception e) {
                listener.onError(e);
            }
        });
    }
    
    public interface OnCompleteListener {
        void onSuccess(long id);
        void onError(Exception e);
    }
}

// 在 Activity 中观察 LiveData
public class MainActivity extends AppCompatActivity {
    private VocabularyRecordRepository repository;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        repository = new VocabularyRecordRepository(
            AppDatabase.getInstance(this).vocabularyDao()
        );
        
        // 观察数据变化
        repository.getAllVocabulary().observe(this, vocabularyList -> {
            updateUI(vocabularyList);
        });
        
        repository.getMasteredCount().observe(this, count -> {
            tvVocabularyCount.setText(count + " 词");
        });
    }
    
    private void saveData() {
        VocabularyRecordEntity entity = new VocabularyRecordEntity();
        // ... 设置数据
        
        repository.addVocabularyRecord(entity, new OnCompleteListener() {
            @Override
            public void onSuccess(long id) {
                runOnUiThread(() -> {
                    Toast.makeText(MainActivity.this, "保存成功", Toast.LENGTH_SHORT).show();
                });
            }
            
            @Override
            public void onError(Exception e) {
                runOnUiThread(() -> {
                    Toast.makeText(MainActivity.this, "保存失败", Toast.LENGTH_SHORT).show();
                });
            }
        });
    }
}
```

### 方案3：使用 RxJava（适合复杂数据流）

```java
// 添加依赖
// implementation 'androidx.room:room-rxjava3:2.6.1'
// implementation 'io.reactivex.rxjava3:rxjava:3.1.8'
// implementation 'io.reactivex.rxjava3:rxandroid:3.0.2'

@Dao
public interface VocabularyDao {
    @Query("SELECT * FROM vocabulary_records")
    Flowable<List<VocabularyRecordEntity>> getAllVocabulary();
    
    @Insert
    Single<Long> insert(VocabularyRecordEntity vocabulary);
}

// 在 Repository 中
public class VocabularyRecordRepository {
    private VocabularyDao vocabularyDao;
    
    public Flowable<List<VocabularyRecordEntity>> getAllVocabulary() {
        return vocabularyDao.getAllVocabulary()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread());
    }
    
    public Single<Long> addVocabulary(VocabularyRecordEntity vocabulary) {
        return vocabularyDao.insert(vocabulary)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread());
    }
}

// 在 Activity 中
public class MainActivity extends AppCompatActivity {
    private CompositeDisposable disposables = new CompositeDisposable();
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        disposables.add(
            repository.getAllVocabulary()
                .subscribe(
                    list -> updateUI(list),
                    error -> showError(error)
                )
        );
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        disposables.clear();
    }
}
```

## 实施步骤

1. **移除 allowMainThreadQueries()**
2. **选择合适的异步方案**（建议LiveData）
3. **修改所有DAO方法**
4. **更新Repository层**
5. **改造Activity/Fragment中的数据操作**
6. **添加加载状态UI**（ProgressBar等）
7. **测试验证**

## 预期效果

- ✅ UI流畅度提升90%以上
- ✅ 避免ANR问题
- ✅ 提升用户体验
- ✅ 符合Android最佳实践


