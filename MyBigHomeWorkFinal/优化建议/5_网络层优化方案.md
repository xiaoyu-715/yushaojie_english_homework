# 网络层优化方案

## 当前问题

项目中引入了 OkHttp 和 Gson，但看起来没有充分利用：
- 缺少统一的网络请求封装
- 没有错误处理机制
- 缺少请求拦截器（日志、认证等）
- 词汇数据硬编码在代码中

## 优化方案：Retrofit + OkHttp + Gson

### 1. 添加依赖

```kotlin
// app/build.gradle.kts
dependencies {
    // 网络请求
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
    implementation("com.squareup.okhttp3:okhttp:4.12.0")
    implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")
    
    // 协程支持（可选）
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
    
    // RxJava 支持（可选）
    // implementation("com.squareup.retrofit2:adapter-rxjava3:2.9.0")
}
```

### 2. 定义 API 接口

```java
// api/VocabularyApiService.java
public interface VocabularyApiService {
    
    // 获取词汇列表
    @GET("api/vocabulary/list")
    Call<ApiResponse<List<VocabularyDto>>> getVocabularyList(
        @Query("category") String category,
        @Query("difficulty") String difficulty,
        @Query("limit") int limit
    );
    
    // 获取每日一句
    @GET("api/daily-sentence")
    Call<ApiResponse<DailySentenceDto>> getDailySentence();
    
    // 获取题目
    @GET("api/questions/{examType}")
    Call<ApiResponse<List<QuestionDto>>> getQuestions(
        @Path("examType") String examType,
        @Query("limit") int limit
    );
    
    // 提交学习记录
    @POST("api/study-records")
    Call<ApiResponse<Void>> submitStudyRecord(
        @Body StudyRecordDto record
    );
    
    // 同步用户数据
    @POST("api/sync")
    Call<ApiResponse<SyncDataDto>> syncUserData(
        @Body SyncRequestDto request
    );
    
    // 获取学习统计
    @GET("api/statistics")
    Call<ApiResponse<StatisticsDto>> getStatistics(
        @Query("userId") String userId,
        @Query("startDate") String startDate,
        @Query("endDate") String endDate
    );
}
```

### 3. 创建数据模型

```java
// model/dto/ApiResponse.java
public class ApiResponse<T> {
    private int code;
    private String message;
    private T data;
    
    public boolean isSuccess() {
        return code == 200;
    }
    
    // Getters and setters
}

// model/dto/VocabularyDto.java
public class VocabularyDto {
    private String word;
    private String pronunciation;
    private String meaning;
    private String example;
    private String difficulty;
    private List<String> synonyms;
    
    // Getters and setters
}

// model/dto/QuestionDto.java
public class QuestionDto {
    private Long id;
    private String questionText;
    private List<String> options;
    private int correctAnswer;
    private String explanation;
    private String examType;
    private String category;
    
    // Getters and setters
}
```

### 4. 配置 Retrofit

```java
// network/RetrofitClient.java
public class RetrofitClient {
    
    private static final String BASE_URL = "https://api.yourserver.com/";
    private static RetrofitClient instance;
    private Retrofit retrofit;
    
    private RetrofitClient() {
        OkHttpClient okHttpClient = new OkHttpClient.Builder()
            // 连接超时
            .connectTimeout(15, TimeUnit.SECONDS)
            // 读取超时
            .readTimeout(15, TimeUnit.SECONDS)
            // 写入超时
            .writeTimeout(15, TimeUnit.SECONDS)
            // 添加日志拦截器
            .addInterceptor(new HttpLoggingInterceptor()
                .setLevel(HttpLoggingInterceptor.Level.BODY))
            // 添加认证拦截器
            .addInterceptor(new AuthInterceptor())
            // 添加通用参数拦截器
            .addInterceptor(new CommonParamsInterceptor())
            // 重试机制
            .retryOnConnectionFailure(true)
            .build();
        
        retrofit = new Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create(createGson()))
            // RxJava 支持
            // .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
            .build();
    }
    
    public static synchronized RetrofitClient getInstance() {
        if (instance == null) {
            instance = new RetrofitClient();
        }
        return instance;
    }
    
    public <T> T createService(Class<T> serviceClass) {
        return retrofit.create(serviceClass);
    }
    
    private Gson createGson() {
        return new GsonBuilder()
            .setDateFormat("yyyy-MM-dd HH:mm:ss")
            .serializeNulls()
            .create();
    }
}
```

### 5. 创建拦截器

```java
// network/interceptor/AuthInterceptor.java
public class AuthInterceptor implements Interceptor {
    
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        
        // 获取 Token（从 SharedPreferences 或其他地方）
        String token = getAuthToken();
        
        if (token == null || token.isEmpty()) {
            return chain.proceed(originalRequest);
        }
        
        // 添加 Authorization header
        Request newRequest = originalRequest.newBuilder()
            .header("Authorization", "Bearer " + token)
            .build();
        
        return chain.proceed(newRequest);
    }
    
    private String getAuthToken() {
        // 从存储中获取 token
        return "";
    }
}

// network/interceptor/CommonParamsInterceptor.java
public class CommonParamsInterceptor implements Interceptor {
    
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request originalRequest = chain.request();
        
        HttpUrl newUrl = originalRequest.url().newBuilder()
            .addQueryParameter("platform", "android")
            .addQueryParameter("version", BuildConfig.VERSION_NAME)
            .addQueryParameter("timestamp", String.valueOf(System.currentTimeMillis()))
            .build();
        
        Request newRequest = originalRequest.newBuilder()
            .url(newUrl)
            .header("Content-Type", "application/json")
            .header("User-Agent", "EnglishLearning-Android/" + BuildConfig.VERSION_NAME)
            .build();
        
        return chain.proceed(newRequest);
    }
}
```

### 6. 创建 Repository（网络+本地）

```java
// repository/VocabularyRemoteRepository.java
public class VocabularyRemoteRepository {
    
    private final VocabularyApiService apiService;
    private final VocabularyDao localDao;
    private final ExecutorService executorService;
    
    public VocabularyRemoteRepository(VocabularyDao localDao) {
        this.apiService = RetrofitClient.getInstance()
            .createService(VocabularyApiService.class);
        this.localDao = localDao;
        this.executorService = Executors.newSingleThreadExecutor();
    }
    
    // 从网络加载词汇并缓存到本地
    public void fetchAndCacheVocabulary(String category, 
                                       int limit,
                                       OnResultListener<List<VocabularyRecordEntity>> listener) {
        executorService.execute(() -> {
            try {
                // 先从本地获取
                List<VocabularyRecordEntity> cachedData = 
                    localDao.getVocabularyByDifficulty(category);
                
                if (!cachedData.isEmpty()) {
                    listener.onSuccess(cachedData);
                }
                
                // 从网络获取最新数据
                Response<ApiResponse<List<VocabularyDto>>> response = 
                    apiService.getVocabularyList(category, "medium", limit).execute();
                
                if (response.isSuccessful() && response.body() != null) {
                    ApiResponse<List<VocabularyDto>> apiResponse = response.body();
                    
                    if (apiResponse.isSuccess()) {
                        List<VocabularyDto> dtoList = apiResponse.getData();
                        List<VocabularyRecordEntity> entities = 
                            convertToEntities(dtoList);
                        
                        // 保存到本地数据库
                        localDao.insertVocabularies(entities);
                        
                        listener.onSuccess(entities);
                    } else {
                        listener.onError(new Exception(apiResponse.getMessage()));
                    }
                } else {
                    listener.onError(new Exception("Network error: " + response.code()));
                }
            } catch (IOException e) {
                // 网络错误，返回缓存数据
                List<VocabularyRecordEntity> cachedData = 
                    localDao.getVocabularyByDifficulty(category);
                if (!cachedData.isEmpty()) {
                    listener.onSuccess(cachedData);
                } else {
                    listener.onError(e);
                }
            }
        });
    }
    
    // 提交学习记录到服务器
    public void submitStudyRecord(StudyRecordEntity record, 
                                  OnResultListener<Void> listener) {
        executorService.execute(() -> {
            try {
                StudyRecordDto dto = convertToDto(record);
                Response<ApiResponse<Void>> response = 
                    apiService.submitStudyRecord(dto).execute();
                
                if (response.isSuccessful() && response.body() != null) {
                    if (response.body().isSuccess()) {
                        listener.onSuccess(null);
                    } else {
                        listener.onError(new Exception(response.body().getMessage()));
                    }
                } else {
                    listener.onError(new Exception("Submit failed"));
                }
            } catch (IOException e) {
                // 提交失败，标记为待同步
                record.setSyncStatus("pending");
                listener.onError(e);
            }
        });
    }
    
    private List<VocabularyRecordEntity> convertToEntities(List<VocabularyDto> dtoList) {
        List<VocabularyRecordEntity> entities = new ArrayList<>();
        for (VocabularyDto dto : dtoList) {
            VocabularyRecordEntity entity = new VocabularyRecordEntity();
            entity.setWord(dto.getWord());
            entity.setPronunciation(dto.getPronunciation());
            entity.setMeaning(dto.getMeaning());
            entity.setDifficulty(dto.getDifficulty());
            entities.add(entity);
        }
        return entities;
    }
    
    public interface OnResultListener<T> {
        void onSuccess(T data);
        void onError(Exception e);
    }
}
```

### 7. 在 ViewModel 中使用

```java
public class VocabularyViewModel extends ViewModel {
    
    private final VocabularyRemoteRepository remoteRepository;
    private final MutableLiveData<List<VocabularyItem>> vocabularyList;
    private final MutableLiveData<Boolean> isLoading;
    private final MutableLiveData<String> errorMessage;
    
    public void loadVocabularyFromNetwork(String category) {
        isLoading.setValue(true);
        
        remoteRepository.fetchAndCacheVocabulary(
            category, 
            20, 
            new OnResultListener<List<VocabularyRecordEntity>>() {
                @Override
                public void onSuccess(List<VocabularyRecordEntity> data) {
                    vocabularyList.postValue(convertToItems(data));
                    isLoading.postValue(false);
                }
                
                @Override
                public void onError(Exception e) {
                    errorMessage.postValue("加载失败: " + e.getMessage());
                    isLoading.postValue(false);
                }
            }
        );
    }
}
```

### 8. 错误处理封装

```java
// network/ApiException.java
public class ApiException extends Exception {
    private int code;
    private String message;
    
    public static ApiException handleException(Throwable e) {
        if (e instanceof HttpException) {
            HttpException httpException = (HttpException) e;
            return new ApiException(httpException.code(), "网络错误");
        } else if (e instanceof JsonParseException) {
            return new ApiException(-1, "数据解析错误");
        } else if (e instanceof ConnectException) {
            return new ApiException(-1, "连接失败");
        } else if (e instanceof SocketTimeoutException) {
            return new ApiException(-1, "请求超时");
        } else {
            return new ApiException(-1, "未知错误");
        }
    }
}
```

### 9. 添加离线支持

```java
// 添加缓存拦截器
public class CacheInterceptor implements Interceptor {
    
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request request = chain.request();
        
        if (!isNetworkAvailable()) {
            // 无网络时，强制使用缓存
            request = request.newBuilder()
                .cacheControl(CacheControl.FORCE_CACHE)
                .build();
        }
        
        Response response = chain.proceed(request);
        
        if (isNetworkAvailable()) {
            // 有网络时，缓存1分钟
            int maxAge = 60;
            response = response.newBuilder()
                .removeHeader("Pragma")
                .removeHeader("Cache-Control")
                .header("Cache-Control", "public, max-age=" + maxAge)
                .build();
        } else {
            // 无网络时，缓存7天
            int maxStale = 60 * 60 * 24 * 7;
            response = response.newBuilder()
                .removeHeader("Pragma")
                .removeHeader("Cache-Control")
                .header("Cache-Control", "public, only-if-cached, max-stale=" + maxStale)
                .build();
        }
        
        return response;
    }
}

// 在 OkHttpClient 中添加缓存
OkHttpClient client = new OkHttpClient.Builder()
    .cache(new Cache(context.getCacheDir(), 10 * 1024 * 1024)) // 10MB
    .addNetworkInterceptor(new CacheInterceptor())
    .build();
```

## 预期收益

- ✅ 统一的网络请求管理
- ✅ 自动错误处理和重试
- ✅ 离线缓存支持
- ✅ 请求日志记录
- ✅ 易于扩展和维护
- ✅ 支持数据同步

## 实施建议

1. 先搭建基础网络框架
2. 实现一个简单的API（如每日一句）
3. 测试成功后逐步迁移其他功能
4. 保留本地数据作为降级方案


